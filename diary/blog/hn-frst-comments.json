[
    "\n                  Worked on two GraphQL projects; I was quickly cured from the hype. I recognize a lot of points in this article.In both these projects the GraphQL had started small. I came in during a more mature phase of these projects (2 and 4 years). That's where the requirements are harder, more specific, and overall complexity has grown. Adoption and demand on the API were growing quickly. Hence you logically spend more time debugging, this is true for any codebase.But GraphQL has everything in it to make such problems even harder. And both these projects had clear signs of \"learning-on-the-go\" with loads of bad practices (especially for the N+1 problem). Issue descriptions were much vaguer, harder to find in logs and performance issues popped up in the most random places (code that had been running and untouched for ages).Fun fact; in both these projects the original devs who set it up were no longer involved. Probably spreading their evangalism further elsewhere.RPC and REST are just more straightforward to monitor, log, cache, authorize and debug.\n                      \n                      reply\n                  \n      ",
    "\n                  I've run into all of these issues running a GraphQL API and, while they aren't easy, they aren't exactly intractable either.  Let's not pretend that OpenAPI/REST or Protobuf are perfect alternatives.  They've each got their warts and tradeoffs.The thing that I still _like_ about GraphQL is that it's a nice approach for expressing complex domain models over a protocol.  If you are working with either REST or protos, you may still have to reason about graph-like structures but without the benefit of a graph-like schema.\n                      \n                      reply\n                  \n      ",
    "\n                  Aside from all the valid points listed in the blog I found out that the frontend engineers in my company save some queries in central library and reuse them even if they don't need all the field returned by this array just to save themselves the time they spend writing queries so they are basically using GraphQL as REST at the end and now we have the worst of both worlds.\n                      \n                      reply\n                  \n      ",
    "\n                  >1. Write a succinct human readable TypeSpec schema\n>2. Generate an OpenAPI YAML spec from itWhy? Isn't YAML human readable?\n                      \n                      reply\n                  \n      ",
    "\n                  I must be the only one who found GraphQL, used it in a small project, and liked almost every bit of it.  I used Apollo Client and graphql-codegen to generate types and functions for Vue 3, and nothing else could touch it.  It wasn't all smooth sailing of course: I did find defining new scalar types to be fiddly, and I couldn't really even make proper use of union types, directives, or even enums due to the impedance mismatch of Apollo Client (JS) and API Platform (PHP).  The latter had a lot of nice features in implementing the API backend itself, but the poor documentation for its graphql support held me back.  But even the super-basic graphql subset I did use caught a great many errors at the type level where other solutions would not have.These days, given the freedom to write the backend in TS too, I might look into tRPC instead.  One thing's for sure, I won't be going back to OpenAPI unless and until I can fully autogenerate api.yaml and otherwise never have to touch it again (getting there with zod+openapi on another project, but it's nowhere near as easy as graphql-codegen doing all the things with one introspection query).\n                      \n                      reply\n                  \n      ",
    "\n                  Having worked extensively with OpenAPI, GraphQL, plain JSON/HTTP, and gRPC/Buf Connect services, most of this rings true for me.One thing the author doesn't mention is that you can limit the set of queries clients can call in a GraphQL service, by hash or signature. This mitigates a lot of the gnarly performance and security issues because the attack surface goes from \"arbitrary queries\" to \"queries you've already 'vetted'\", where you can look at things like complexity, ACL behavior, etc ahead of time. Since clients (in my experience) aren't usually modifying GQL queries at runtime, this is a pretty good tradeoff.All that said, I find Buf Connect to be the best set of tradeoffs for most projects: strongly typed servers and clients, strong ecosystem support around protobuf (e.g. to generate an OpenAPI spec), a standard HTTP/JSON interface for easy curl et al compatibility, etc.OpenAPI as the source of truth is annoying because it's too flexible, and it's rarely possible to generate type-safe servers + clients from an OpenAPI spec without running into one edge case or another.\n                      \n                      reply\n                  \n      ",
    "\n                  What about the benefits/drawbacks of the graphql client in a web app, e.g. Apollo [1], Relay [2]? You get a client-side normalized cache of all data fetched by any query. Here's a handful of benefits:- If data already exists in cache, a query will return that data instead of making a network request.- Everything that has a data dependency on something in the cache will automatically update when the data is updated, e.g. after a mutation.- Cache data can be optimistically updated before the request completes, UI that queries this data will automatically update.- Components will automatically refetch data if they need to, e.g. if an object is partially updated.The pain points are pretty painful though:- Really hard to debug unexpected refetches.- Normalizing the data for the cache comes at a cost, it can be pretty slow for big responses.- You quickly realise you need to really understand how the client works under the hood to be productive with debugging/complex behaviour.I see it as a case of \"this is the worst API/client, except for all the others\". \n I'm curious to hear how people using non-graphql APIs are managing data in the client in web-apps with complex data needs?[1] https://www.apollographql.com/docs/react/why-apollo\n[2] https://relay.dev/\n                      \n                      reply\n                  \n      ",
    "\n                  Additional graph pain points I'd add:Reliability:* Not null fields in a distributed system are a lie. Clients write code assuming something is not null, so a query that fetches data from N sub systems breaks the entire page when one of them fails.Performance:* People say you only need to fetch just what the page wants but in practice clients create re-usable fragments for every object in the system and use it everywhere. Any time a new field is added, every api call fetches that new field adding latency everywhere* clients are unaware of the underlying topology and add fields that are usually harmless but have bad tail latencies.* The completely generic nature of the API means the backend can't optimize performance for a specific page. E.g. if one API has nasty tails, but it's not that important for this page, the backend could time it out at some reasonable value instead of holding up the entire request\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL is the peanut butter to Reacts chocolate at FB.It works there because1. Every user is logged in. Is there anything you can do at FB without giving up something to the Zuck?2. Because it's all behind a login, you can front load the first login/request with a giant SPA and then run all the custom queries you want.3. everything at FB is some sort of blended context (my user, someone else's user, a permissions interaction)... security is baked in to every field.4. Because of permissions, and login requirement it's hard to be a bad actor (FB just locks you out, nothing is public).If you have a SPA and logged in user requirement and that robust permissions model then GraphQL might make sense... Otherwise its a shining example of conways law and might not be fit for your org... The same can be said for react too.\n                      \n                      reply\n                  \n      ",
    "\n                  As an alternative datapoint, we use GraphQL for a medium-sized app, are several years in, and are pretty happy with it. The downsides he mentions are all true, but on the other hand, are addressable, and for us feel worth the benefits of getting flexibility and control on the client-side.\n                      \n                      reply\n                  \n      ",
    "\n                  I generally agree and am likewise \"over\" GraphQL. Having said that, I disagree on some of the finer points.First, some of these issues--authorization, security, N+1--can be mitigated by using something like Prisma, PostGraphile, or Hasura, instead of crafting GraphQL backends with code.Second, there are gains to be made by compiling a GraphQL operation to a single operation in the underlying database's query language (e.g. SQL)--when that's possible--rather than by following the \"resolver and data-loader\" catechism.Third, as I've written elsewhere recently, I think the N+1 problem is overblown. Not that it doesn't exist, but just that it only sometimes exists and usually isn't as bad as is often claimed. But again, this is eliminated by switching to a compiler approach anyway, so it's not worth making a federal case over it.Despite all this, like I said I'm still over GraphQL. If you must implement it, try to use one of the tools mentioned above if you can.\n                      \n                      reply\n                  \n      ",
    "\n                  when will people learn - you're not Facebook, or will never likely reach facebook scale. Graphql, Relay, React were things etc made for Facebook at facebook scale i.e whether that's in terms of engineers, resources or actual tech problems.There's plenty of other sites / services that receive almost as close to FB properties in terms of traffic yet you never hear them pushing all those tools. Trading firms, Porn firms etc. Some just use REST + JSON or RPC + JSON.Wish us an industry would read Joel's Spolsky's Fire and Motion article: While you're fighting tools built by FB you're not making stuff for your customers.Revenue / Profit >> Tech\n                      \n                      reply\n                  \n      ",
    "\n                  Kudos to the author for reevaluating his opinion and changing heart on a technology he admits to have championed before.IMO GraphQL is a technological dead end in much the same way as Mongo is.They were both conceived to solve a perceived problem with tools widely adopted at the time, but ended up with something which is even worse, while the tools they were trying to replace rapidly matured and improved.Today OpenAPI REST and Postgres are rightfully considered as the defaults, you even have PostgREST combining them, while most of those who adopted Mongo or GraphQL have either long migrated or are stuck discussing migrations.\n                      \n                      reply\n                  \n      ",
    "\n                  Back in 2021, I asked one of our devs who badly wanted GraphQL for his resume (this dev left in 6 months) to address the following issues:- GraphQL performance issues- GraphQL makes tasks more complex- GraphQL schemas confuse junior devs, higher entry level- REST cache easier- REST if you understand what you are doing ... can do the same- REST is better for error handling and toolingNow in 2024, I clearly see LLMs gives much better autocomplete for REST or SDK code generated with protobuf ecosystemThere is not enough code repos based on GraphQL for LLMs to reason.If you have like minded people who loves GraphQL, nothing can stop them but at higher and broader level it's a huge risk for dev velocity (like anything else if you dont know what you are doing)\n                      \n                      reply\n                  \n      ",
    "\n                  >GraphQL is an incredible piece of technology that has captured a lot of mindshare since I first started slinging it in production in 2018.6 years. For a lot of people, that was also the time ( 2013 - 2019 ) they moved from SPA or Client Side Rendering and started looking or move back to HTML+ approach.So may be for any company operating on Boring Technology principle, you should not choose any hyped tech until they have been battle tested by the market for 7 years.\n                      \n                      reply\n                  \n      ",
    "\n                  One of the major issues I have with GraphQL from the get go is that it introduces it's own syntax instead of using a commonly understood and established _data_ format like JSON or similar.Same problem with Prisma Model definitions and other such things.Please, if you make a new thing and it fits neatly into a data format, use a data format! Let me use all of those well established libraries, schema definitions and programming concepts in order to generate, parse and make sense of your thing. Let me seamlessly write your language with the data structures I already know in my language if that's possible.Don't make it pretty, make it usable.\n                      \n                      reply\n                  \n      ",
    "\n                  I’ve found success just using GraphQL internally (with tools like Hasura or Postgraphile + row level security done strategically) and not exposing it directly externally. That way you can trust the clients and it unblocks frontend devs to accomplish what they need.\n                      \n                      reply\n                  \n      ",
    "\n                  I like restful API’s the most. Graphql is cool if you need data combined that is not nicely available in the restful endpoints. But I think that could mostly be solved with good endpoints that help with the actual use cases. When restful endpoints are hard to use, in a lot of cases it is because they are to much focused on how it is easy to write server side, then it is to consume them.\n                      \n                      reply\n                  \n      ",
    "\n                  I never got into GraphQL. It always felt like a lot of complexity for little gain (I'm full-stack). People always jump on tools created by tech giants but they solve different problems than the vast majority of companies.\n                      \n                      reply\n                  \n      ",
    "\n                  I only have one experience with a client using GraphQL and it was horrendous.My biggest complain is there seemed to be no way to just to query all fields. I know that is intentional and the point of GraphQL.. but they should support something for the server side to enable this.  Maybe they have over the years, I don't know.  But my experience was during the implementation phase the client kept adding new fields that I didn't know about and then I had to constantly ask them for the fields because I thought I was missing data.  If I could have just queried ALL the fields, then saw what came in, and chop them down to what I need.. great.The only way GraphQL seems to make any sense is if everything is basically completely defined and you are at a final project stage.  After many many years of experience... this is rarely the case.Cool piece of technology? Sure.. but hardly practical except in scenarios of extreme amounts of data and only when it makes sense for the client to return specific fields.Although I think still for 95% of even those extreme cases, you just write a REST endpoint that returns the fields that make sense for the query....\n                      \n                      reply\n                  \n      ",
    "\n                  “the main thing your frontend devs like about GraphQL is its self documenting type safe nature”I’ve been saying this for years: fetching multiple things in one query is not something normal-scale apps care about. What devs like about it is client generation and type safety. So OpenAPI, for all its flaws, covers that. GraphQL’s schema language is much more beautiful — hopefully Microsoft’s TypeSpec will take off and we can have the best of both worlds.https://typespec.io/Another point implicit in the piece but not quite stated is that GraphQL aims to make something nice for the API consumer, but the implementation side is a nightmare. It is not worth the tradeoff because eventually, that nightmare leaks out to the consumer because it is too hard to make improvements to the API.\n                      \n                      reply\n                  \n      ",
    "\n                  Working with GraphQL over 6 years, I have seen (and created) many mistakes mentioned in the article. GraphQL is not great but it has worked well for me, you just need to adapt & change mindset to create better interface for your graphQL endpoint.For example, having nested queries more than 2 levels is a no go for me (just like having nested inheritance is basically anti pattern)Focus more on your interface. One way to avoid N+1 and nested query is to required parameter for related fields. For example```user(id: $userId) { {  id\n\n  friends {\n\n    id\n\n    ...\n\n  }\n\n```to```user(id: $userId) {  id\n\n  friends(id: $userId) {\n\n    id\n\n    ...\n\n  }\n\n```\n                      \n                      reply\n                  \n      ",
    "\n                  I never understood peoples positions that GraphQL all of the sudden the frontend can make any Query it wants and control is out of the hands of the backend. That seems orthogonal to my experiences with GraphQL.GraphQL is a protocol and you define the implementation. Some GraphQL implementations like REST implementations try to generate everything for you. That is not \"GraphQL\" but one type.GraphQL is way to query nested APIS. The dataloading N+1 Problems are substantially easier to solve in GraphQL and many frameworks have solutions auto-optimize ORM queries for example.The backend defines the query, the frontend requests it. Simple. Never understood the hate against GQL that now the frontend has all this power. They have exactly as much power as you would have exposed in a Rest Interface just now the backend can actually see all the data it needs at once and optimize.If you are worried about a cartesian product from a GraphQL call I have news for you about production REST systems. Ever seen an engineer do a loop and make n+1 REST calls for resources? It happens more often then you think.REST encourages resource waste. You are getting fields you don't need. Hard to query related objects, etc.Benefits I have reaped with GraphQL:  1. API analysis - I can statically analyze a typescript program and verify their API calls are valid against backend schema.\n  2. Usage analysis - Statically analyzing the schema I can see which fields are still in use and safely refactor.\n  3. Frontend Velocity - The frontend can cange its data needs on the frontend query whatever related objects it needs efficiently without backend changes. You can get all data for a page with 1 call and not have to have page specific endpoints.\n  4. Less backend engineers are needed as API changes less.\n  5. N+1 Optimization much easier to solve in GraphQL then REST\n\nThere are so many advantages to using GraphQL. The only advantage of REST I can think of is for static external APIs.\n                      \n                      reply\n                  \n      ",
    "\n                  I agree with the article, and want to add on that the browser network debugging tools are a pain to use with GraphQL (every request to /api/graphql, can't even quickly filter by endpoint name). I landed instead on OpenAPI, which can feel like a bit of a hoop to jump through sometimes when writing endpoints (but then, so can GraphQL), but the result is equally nice. And it's much easier to get authorization right with REST APIs.I wonder if GraphQL would have been as popular if it was a much smaller shop than facebook launching it. Feels like having a name like FB gets you a tech credibility pass.\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL was the shiny new thing that everyone was excited about and I was also trying to learn and use it too, but I've never found a compelling use-case to use it over REST API. Now that you shared your experiences with it, it give me more reason to stay away from it. Plus, I think it's more productive to stay with the stack I'm very fluent at.\n                      \n                      reply\n                  \n      ",
    "\n                  Ah, this is the advantage I have waiting at least 10 years of everyone I care about whining I need to use a technology. I had a few years of people telling me about graphql and how it is the best etc, but they stopped after a bit and are doing rest endpoints again. So I never tried it even.\n                      \n                      reply\n                  \n      ",
    "\n                  Fine article describing the weak points of GrahQL. I find it a bit poor though that the only recommended alternative is OpenAPI rest APIs.I have no beef against doing REST, jsonRPC etc. Actually I consistently steer people that way. But the documentation format we chose as an industry to build these things with, Swagger, is just disappointing. Some times I think the industry would be at a totally different point had we gone with more powerful standards like API blueprint (or maybe raml).Case in point, I'm consulting an org with roughly 1k engineers right now on improving their API ecosystem and what we are seeing is that the more OpenAPI tooling they use, the worse the DX gets...\n                      \n                      reply\n                  \n      ",
    "\n                  I worked on two projects using GraphQL and don't want to do it again. Both times the backend was a mess and the \"design\" or the lack thereof had all the signs of being written by \"evangelists\" who got bored or got fired leaving the new arrivals to sort out the mess. I'm sure GraphQL is the right fit for some problem domains, but most of the problems I deal with are happily solved with the help of a REST API.\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL always felt to me like it solved the easy part of the problem and offered nothing to solve the hard part. I have a similar response to things like Zanzibar. At the end of the day I want to go and get some stuff out of a database, and that complexity just ends up dominating everything.\n                      \n                      reply\n                  \n      ",
    "\n                  For the service I primarily work on, we've stuck firmly with REST for our internal APIs despite some mild pressure from elsewhere in the company to move to GraphQL. I personally believe it's been the right choice. Not only would it be probably an order of magnitude more complicated to setup and maintain, our REST APIs already are very performant.We've got little to gain, and the lack of flexibility from our POV is a relatively good thing. It gives us direct insight into desired use cases, and since the APIs are internal it lets us provide guidance on potentially better ways of implementing things as well as in some cases being able to provide direct optimizations for specific tasks.\n                      \n                      reply\n                  \n      ",
    "\n                  From a backend point of view, you will never be able to stop front end people from doing the wrong thing with an API.GraphQL makes it easier for front-end developers to do the wrong thing, which is why they love it.\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL basically only really works with monoliths that share the same access-pattern (either everyone logged in, or everyone logged out), it's otherwise a pain to merge multiple different graphql-schemas into a single one (or at least I'm not aware of an elegant way to achieve that).. The worst of two worlds is a micro-services back-end with a graphql Api interface, it makes testing individual services and the Api as a whole quite annoying.I do really like the Api definition part of it though - but I found something like typespec now to be the perfect middle-ground, it allows out you describe your apis similar to a graphql Api without enforcing the graphql engine on you though.\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL is a great choice for internal applications hidden behind strong authentication that do not need to be heavily cached and where things like DoS are less of a concern or no concern at all.It is often a poor choice for websites that should be cached, are publicly accessible and have simple and predictable data access patterns.GraphQL has a fairly flat but very long learning curve which makes it a power tool that is great for those who have learned it in depth. Without that experience one is almost always better off using REST.\n                      \n                      reply\n                  \n      ",
    "\n                  I still love GraphQL, but much of the love comes from using tools like PostGraphile which generates the API for you based on your database schema. I then add my own Javascript plugins as necessary. Going back to REST and hand writing everything gives me the shivers, how much time am I spending just translating data A to data B?Authorization: I do it in the database using roles, row level security and column level security. It works well and I defer everything to PostgreSQL's security controls, it feels like the right place to do it and I don't have to worry about it going out of fashion, PostgreSQL is here to stay. Anybody else who talks to the database directly is also subject to the same authorization rules, which is nice.Introspection: this should really be disabled on production services. Only enable it for development.N+1 problem: I don't really have a problem with N+1 because PostGraphile converts the request into an efficient query. In other cases this problem presents itself in REST too and the article proposes hoisting N+1 queries to the controller, but that's just really moving the problem around, and you can do this with GraphQL too.The other problems, yeah sure they are present and a worry if you're running some highly visible/very loaded public API.\n                      \n                      reply\n                  \n      ",
    "\n                  I've had the \"pleasure\" (/s) of inheriting a pretty large GraphQL API which I've had to maintain for the past few years. I've gone through the process of the hype, and then the sheer frustration. I'm now at the point where I think most people are just using it in the wrong places.GraphQL works pretty well when it's acting as a Backend-For-Frontend. The client can make a single call to get everything it needs at once, the BFF can then fan out to various microservices as needed. The frustrating part is when it's blindly used for something like a monolithic CRUD API with some light permissions. In that scenario you're taking all of the drawbacks, without reaping any of the benefits.I'm really glad to be leaving this project behind as I move jobs, and I'm praying no one suggests using it in my new job. At least not until the industry more broadly understands it in more depth.\n                      \n                      reply\n                  \n      ",
    "\n                  many of these concerns are mitigated by ensuring you are using trusted documents (https://benjie.dev/graphql/trusted-documents)\n                      \n                      reply\n                  \n      ",
    "\n                  Fully agree with the article. I think the summary is that GraphQL was a great idea from the frontend's perspective, but it was never fully worked out from a backend's standpoint.\n                      \n                      reply\n                  \n      ",
    "\n                  Fundamentally, GraphQL is a _query language_, but people keep trying to build/use it as an _API_.\n                      \n                      reply\n                  \n      ",
    "\n                  For something like OpenAPI+JSON REST API, does anyone have recommendations on tooling that would make my life easier?I am also over GraphQL but I really like the api explorers, code completion, type safety, etc.\n                      \n                      reply\n                  \n      ",
    "\n                  There was a very short window of time when you could make very advanced queries over your Facebook friends graph. It was awesome.\n                      \n                      reply\n                  \n      ",
    "\n                  If only developers/managers had their own sense of using the proper tools for the job instead of just swallowing everything the Big Tech shoves down their throat...But when you see those job ads with all these \"great new technologies\" it's hard not to fall into the trap.\n                      \n                      reply\n                  \n      ",
    "\n                  When I saw GraphQL I immediately saw the issues that the poster talks about.  I was amazed that people were drawn to it like a moth to a flame.\n                      \n                      reply\n                  \n      ",
    "\n                  GraphQL is a great way for FE devs to make life harder for BE devs.The entire point is composition + client customization of the response body, but in practice the request schema is never modified. And even if it were, you could just version a REST endpoint.GraphQL is never done \"correctly,\" adds a layer of obscurity to monitoring and error tracing, and I've yet to see a case where it's actually the right tool for the job.Maybe if you need to aggregate calls to multiple services into one, but if you're trying to avoid latency by reducing number of calls, you still eat that latency while the GraphQL server makes those calls for you.GraphQL sucks.\n                      \n                      reply\n                  \n      ",
    "\n                  Whenever you see REST in the article, think RPC. The author even says REST is simpler than GraphQL but I suspect they hadn’t implemented a REST API… ever.\n                      \n                      reply\n                  \n      ",
    "\n                  For web apps (not simple pages), developed by a single full-stack developer, I think the best solution currently is to use Remix's loaders + actions (i.e. no need to create separate API layer) with EdgeDB (EdgeQL is like GraphQL but with capabilities of SQL, and the DB itself has authn+authz baked-in).\n                      \n                      reply\n                  \n      ",
    "\n                  Exposing bare GraphQL the right way can be challenging, totally agree with author on that. Using it on a small project also can be an overkill.But at the same time it doesn’t  have to be that bad. I don’t have this array of issues because I do:\n- query whitelisting for performance and security,\n- data loading to avoid n+1, authentication with whatever works(session cookies, tokens), \n- permission check based on the auth context in a resolver.It works decently for us, allowing to stay away from getting into ESB. Yet have some shared domain, type safety, and easy integration of legacy and new systems/services.I would say a bigger issue for us was to keep it all nicely organized / designed in terms of types and api contracts. But that’s manageable.\n                      \n                      reply\n                  \n      ",
    "\n                  The consensus I get from these comments is GraphQL is ultimately a failure as a REST API alternative. It’s useful for very specific cases that most companies don’t have.\n                      \n                      reply\n                  \n      ",
    "\n                  I've read the article and a few of the responses but have never used GraphQL. However I have a questionWould it be fair to say that GraphQL is extremely useful for internal-only clients? For example an inhouse data store, query service, test status monitor, etc?So many issues disappear when you aren't concerned about bad-actors and you have _some_ control over both client and server.\n                      \n                      reply\n                  \n      ",
    "\n                  Full blown GraphQL is hard to properly support. It needs a lot of developer time to get everything correct, as stated in the article.However, you can go very far with a simpler version of it, just by allowing clients to specify what fields/relations they want and in what context.I'm using a library that I've created for myself for years without any of the problems mentioned in the article.The client side queries are generated by the server at compile time. Each request for an object requires a \"segment\" to be specified. On the server, each segment has the necessary filters/limits automatically applied to prevent data leaks.\n                      \n                      reply\n                  \n      ",
    "\n                  I still enjoy using GraphQL, because it has allowed my teams to move measurably faster when developing APIs over the last half-decade. Some organizations seem fairly allergic to full stack development, but it has broken that barrier in ways I hadn’t witnessed before at my workplace.However, lately I’ve been thinking that with the advent of React Server Components we will see a migration away from GraphQL-focused Frontend applications, and instead move toward other solutions. Such as ones based purely on exposing Postgres databases (e.g. supabase & postgREST) and type safe APIs (e.g. tRPC).\n                      \n                      reply\n                  \n      ",
    "\n                  I heard the argument that it's good because you don't need the server devs to change the backend; you can specify the data you want. As echo'd before, I guess that's great if your frontend and backend can't be developed in sync. Overall, I'd rather improve the development synchronisation/modification problem between backend and frontend than drive the GraphQL tank through the codebase. I guess I'll need to wait another 6 years before I can avoid GraphQL. Marketing-driven fads: exciting at the start of my career, a painful chore now\n                      \n                      reply\n                  \n      ",
    "\n                  Has anyone use graphql for service to service communication?Seems really great to not have each service adhere to another service’s potentially unstable api contract.Especially if that service is owned by another team.\n                      \n                      reply\n                  \n      ",
    "\n                  shameless plug: i have been working on https://querydeck.io/ as a side project to bring the ease of use of graphql to REST apis. the plan is to open source it later in the year once its out of beta\n                      \n                      reply\n                  \n      ",
    "\n                  Never bothered to learn GraphQL - anything being pushed by big tech companies usually in 80% of the cases works for them, but its an overkill for smaller scale projects.Stick to tried and true - monolith, asp.net, angular or blazor front-end, relational database.\n                      \n                      reply\n                  \n      ",
    "\n                      > Data fetching and the N+1 problem\n    > [...] if a field resolver hits an external data source such as a DB or HTTP API, and\n    > it is nested in a list containing N items, it will do those calls N times\n\nWhy is this considered a problem regardless of the situation at hand?F.e. using REST, if the nested list contains on average N-2 items that can be efficiently cached, wouldn't that be better than having the cache constantly invalidated on the aggregation of the parent and its items?\n                      \n                      reply\n                  \n      ",
    "\n                  Skill issue in my case, but I kept fighting against the caching of whatever GraphQL library I was using.Made the dev experience a nightmare because I could never be sure whether it was my code or the client cache or the (actively in beta) server that was causing me to get back wrong data.\n                      \n                      reply\n                  \n      ",
    "\n                  Several years ago, I used to respond to conversations where people hated on Facebook by saying that Facebook had given us at least two great gifts — react and graphql. Since then, I've grown to realize that these might in fact be its two great curses.\n                      \n                      reply\n                  \n      ",
    "\n                  I would have thought all of those were fairly obvious. It is more complex and gives the client a lot more power and control, so the trade-off is inevitable.\n                      \n                      reply\n                  \n      ",
    "\n                  At work we also stopped using Graphql and we only have a few endpoints left to migrate in our internal dashboard.\nNobody that has worked on this project has liked the dx.\n                      \n                      reply\n                  \n      ",
    "\n                  What are people using these days for TypeScript on both ends? I have a home-grown solution that starts with Zod schemas and gives synchronized types on the front end and backend as well as a client for free, but I'm always interested in using something standard\n                      \n                      reply\n                  \n      ",
    "\n                  Can only agree with author on all points. GraphQL was nice for the types, and precious little else. But we have better solutions utilizing just the types now, so it was still valuable.\n                      \n                      reply\n                  \n      ",
    "\n                  A few weeks ago, I read that tRPC is an interesting alternative.\n                      \n                      reply\n                  \n      ",
    "\n                  My $0.02 here:GraphQL makes sense only at a certain scale when you have multiple APIs built by multiple teams that need to be exposed as a single endpoint.  GraphQL as an API or APIs is the perfect use case and the one that it was designed for.In every other case, REST is harder to do wrong and easier to do right.  The tooling for it is widely supported and well known.  Every aspect of building an easy to use, easy to own, easy to scale API is -- well -- just easier with REST.I have seen more than a few small, 4-8 person engineering teams reach for GraphQL and then wonder why every cycle starts feeling slow.  In a 4-8 person team, the devs are usually working full stack and if not, then they are working closely enough that having a highly flexible API layer servicing the front-end doesn't make any sense since it's either the same devs or they're one Slack ping away from getting the right shape from the backend in one simple `GET`.Like the author, I've found that the story with OpenAPI nowadays is really good.  I have a short writeup here with .NET that shows hot re-generation of the API into a TypeScript definition that can be used with React, Vue, or your framework of choice: https://chrlschn.dev/blog/2023/10/end-to-end-type-safety-wit...This workflow is super productive and perfect for small teams working full stack; far easier than getting GQL right.\n                      \n                      reply\n                  \n      ",
    "\n                  The hype train strikes yet again! In fellow consultancy circles, we were giving talks on exactly this back in '17 and '18, but the hype train was too strong then. It was even harder to convince this same crowd that SPAs are usually a bad idea, and emerging technology like Hotwire or LiveView would soon eclipse the SPA-obsessed culture. GraphQL is immensely powerful and useful for its exact use case, and extremely burdensome and expensive for any other use case. If you dont already know that use case, YAGNI. The same can be said for any hype train. The problem with any kind of hype train in tech is everyone looks for reasons to use whatever the new hyped thing is, rarely does anyone determine if the new hyped thing actually fits their use case(s). This will continue so long as there is a dichotomy of culture between youths and those with lengthy experience. We old people will continue to point out exactly why this or that is pure hype, and will continue to be drowned out by the emotions that come along with participating in hype.\n                      \n                      reply\n                  \n      "
]